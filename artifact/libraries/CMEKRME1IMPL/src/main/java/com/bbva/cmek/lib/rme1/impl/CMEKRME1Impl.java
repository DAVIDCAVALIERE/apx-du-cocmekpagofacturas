package com.bbva.cmek.lib.rme1.impl;

import com.bbva.apx.exception.db.NoResultException;
import com.bbva.cmek.dto.bill.BillRecordDTO;
import com.bbva.cmek.dto.bill.BillStatusEnum;
import com.bbva.cmek.dto.bill.ErrorCodeEnum;
import com.bbva.cmek.dto.bill.PaymentDTO;
import com.datiobd.daas.Parameters;
import com.datiobd.daas.conf.EnumOperation;
import com.datiobd.daas.conf.MongoConnectorException;
import com.datiobd.daas.model.DocumentWrapper;
import org.bson.Document;
import org.bson.types.ObjectId;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigDecimal;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * The CMEKRME1Impl class...
 */
public class CMEKRME1Impl extends CMEKRME1Abstract {

    private static final Logger LOGGER = LoggerFactory.getLogger(CMEKRME1Impl.class);

    private final String QUERY_SELECT = "bill.selectById";
    private final String QUERY_UPDATE = "bill.updateStatusById";
    private final String MONGODB_DATABASE_NAME = "BDMONGOBILL";
    private final String MONGODB_COLLECTION_NAME = "c_cmek_bill_payment";
    private final String MONGODB_ID_AUTOGENERATED = "_id";

    //Metodo que consulta una factura puntual en la BD oracle
    private BillRecordDTO executeGetBill(String billId) {
        BillRecordDTO response = null;

        // al usar select o interacciones con la base de datos, se recomienda usar un try catch
        // para manejar las excepciones de datos
        try {
            //Si solo se consulta un registro se usa el siguiente
            //El primer parametro es el nombre de la propiedad del query a usar
            //Si el query a utilizar tiene datos variables con ?,
            // como parametros adicionales separados por , Se envian todos los que se requieran
            Map<String, Object> registry = jdbcUtils.queryForMap(QUERY_SELECT, billId);

            //Si se requiere que la respuesta sea una lista se usa el siguiente
            //List<Map<String, Object>> registries = jdbcUtils.queryForList(QUERY_SELECT,queryParams);

            //Se valida que traiga el registro de la base de datos
            if (registry != null) {
                if (!registry.isEmpty()) {
                    //al tener datos de la DB, se colocan en el objeto de respuesta.
                    response = new BillRecordDTO();

                    //Sobre el registro se usa el get colocando el nombre del campo de la tabla que se quiere obtener
                    //Debido que el metodo retorna un objeto, se debe hacer la homologacion o mapeo
                    response.setBillId((String) registry.get("BILL_ID"));
                    response.setGenerationDate((Date) registry.get("GENERATION_DATE"));
                    response.setExpirationDate((Date) registry.get("EXPIRATION_DATE"));

                    // Normalmente los numeros grandes de Oracle, se deben recibir como
                    // Bigdecimal y desde ese objeto obtener el Int, Long o Double segun se
                    // se necesita.
                    BigDecimal billAmount = (BigDecimal) registry.get("BILL_AMOUNT");
                    response.setBillAmount(billAmount.longValue());

                    response.setBillStatus((String) registry.get("BILL_STATUS"));
                    response.setBillUser((String) registry.get("BILL_USER"));
                    response.setBillProvider((String) registry.get("BILL_PROVIDER"));
                    response.setBillUpdateDate((Date) registry.get("BILL_UPDATE_DATE"));
                }
            }
            // Cuando no hay un datos en la respuesta del select, la utilidad genera este error
            // que debe controlarse
        } catch (NoResultException exc) {
            LOGGER.error("No hay datos", exc);
        }

        return response;
    }

    //Metodo que actualiza el estado de una factura en el oracle
    private boolean executeUpdateBillStatus(String billId, String billStatus) {
        boolean response = false;

        //Si el query a utilizar tiene datos variables con nombre, se coloca el nombre como String y su valor
        Map<String, Object> queryParams = new HashMap<>();
        queryParams.put("billId", billId);
        queryParams.put("status", billStatus);

        //Si se elimina, inserta o modifica se usa el siguiente
        //El primer parameter es el nombre de la propiedad del query a usar
        //El segundo parameter es el arreglo con los datos variables del query
        //La respuesta de este metodo es un entero que es el contador de los registros afectados, si es 0 es que no hizo nada.
        int affectedregistries = jdbcUtils.update(QUERY_UPDATE, queryParams);

        //Se valida que se haya modificado algo y se retorna true o false
        response = affectedregistries > 0;

        return response;
    }

    //Metodo que registra el pago como un documento en una base de datos mongo
    private String executeRegisterPayment(String billId, String accountNumber, long billAmount) {
        String response = null;

        //Parametria para levantar la conexion con MongoDB
        Map<String, Object> mongoDbParameters = new HashMap<>();
        //Define el nombre la base de datos a usar
        mongoDbParameters.put(Parameters.DATABASE_PROPERTY_NAME, MONGODB_DATABASE_NAME);
        //Propiedad obligatoria para usar la utilidad de MongoDB
        mongoDbParameters.put(Parameters.API_OR_REST, Parameters.API);
        //Define el nombre la coleccion a utilizar en MongoDB
        mongoDbParameters.put(Parameters.COLLECTION, MONGODB_COLLECTION_NAME);

        //MongoDB utiliza la estructura de documentos para almacenar informacion en las colecciones
        //Ese documento tiene los datos a guardar
        Document document = new Document();
        document.put("billId", billId);
        document.put("accountNumber", accountNumber);
        document.put("billAmount", billAmount);
        document.put("paymentDate", new Date());

        //Una vez se tiene el documento a guardar en MongoDB, se debe transformar a String
        String mongoRegistry = document.toJson();

        //Se realiza la estructuracion del mensaje y la operacion en MongoDB
        try {
            //Se crea el wrapper del documento con el JSON que tiene los datos a guardar
            DocumentWrapper documentWrapper = DocumentWrapper.parse(mongoRegistry);
            //Dentro de la parametria de conexion a mongo se incluye el documento a inyectar
            mongoDbParameters.put(Parameters.DOCUMENT, documentWrapper);
            //Se ejecuta la operacion MongoDB con los parametros definidos previamente
            this.daasMongoConnector.executeWithNoReturn(EnumOperation.INSERT_ONE, mongoDbParameters);

            //MongoDB al crear un documento genera un identificador automatico
            // este campo dentro del documento se llama _id y es de tipo org.bson.types.ObjectId
            // Este valor lo usaremos en la practica como el id de confirmacion de pago
            ObjectId objectId = (ObjectId) documentWrapper.get(MONGODB_ID_AUTOGENERATED);
            response = objectId.toHexString();
        } catch (MongoConnectorException e) {
            LOGGER.error("error al ejecutar la inserccion {}", e);
        }

        return response;
    }

    //Metodo que realiza las validaciones funcionales de la operacion
    private boolean executeValidateBillToPayment(String billId, long billAmount) {
        boolean response = false;

        //Consulta los datos de la factura
        BillRecordDTO billRecordDTO = this.executeGetBill(billId);

        //Valida que haya datos de la factura en la base de datos
        response = billRecordDTO != null;

        if (response) {
            //Valida que la factura este en estado VIGENTE
            response = BillStatusEnum.VIGENTE.name().equals(billRecordDTO.getBillStatus());
        } else {
            addAdvice(ErrorCodeEnum.CMEK12000001.getCodError());
        }

        if (response) {
            //Obtiene la fecha actual para comparar
            Date current = new Date();
            //Valida que la fecha actual sea menor o igual que la fecha de vencimiento de la factura
            response = current.compareTo(billRecordDTO.getExpirationDate()) <= 0;
        }

        if (response) {
            //Valida que el monto ingresado sea igual que el valor de la factura en la base de datos
            response = billAmount == billRecordDTO.getBillAmount();

            if (!response)
                addAdvice(ErrorCodeEnum.CMEK12000002.getCodError());
        }

        return response;
    }

    @Override
    public PaymentDTO executeDoBillPayment(PaymentDTO request) {
        PaymentDTO response = null;

        boolean doPayment = false;
        boolean isValidAccount = false;

        //Valida que la factura sea valida
        boolean isValidBill = this.executeValidateBillToPayment(request.getBill().getNumber(), request.getBill().getAmount());

        if (isValidBill) {
            //Valida que la cuenta sea valida y tenga saldo
            isValidAccount = cmekRME2.executeValidateAccountToPayment(request.getAccount().getId(), request.getBill().getAmount());

            if (!isValidAccount)
                addAdvice(ErrorCodeEnum.CMEK12000004.getCodError());
        } else
            addAdvice(ErrorCodeEnum.CMEK12000003.getCodError());

        doPayment = isValidBill && isValidAccount;
        //Si la cuenta es válida y la factura también realiza el pago
        if (doPayment) {
            //Para la práctica el pago será registrar en mongo y actualizar el estado de la factura
            String paymentId = this.executeRegisterPayment(request.getBill().getNumber(), request.getAccount().getId(), request.getBill().getAmount());
            this.executeUpdateBillStatus(request.getBill().getNumber(), BillStatusEnum.PAGADO.name());

            response = request;
            response.setId(paymentId);
            response.setOperationDateTime(new Date());
        }

        return response;
    }
}
